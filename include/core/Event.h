#pragma once

#include "config/Export.h"

#include <cstdint>
#include <variant>
#include <string>
#include <iosfwd>

namespace dagbase
{
	class ConfigurationElement;
}

namespace dagui
{
	class Widget;

	enum ButtonMask : std::uint32_t
	{
		BUTTON_NONE,
		BUTTON_PRIMARY_BIT = 1<<0,
		BUTTON_SECONDARY_BIT = 1<<1,
		BUTTON_MIDDLE_BIT = 1<<2
	};

	extern std::string DAGUI_API buttonMaskToString(ButtonMask value);

	extern ButtonMask DAGUI_API parseButtonMask(const std::string& str);

	struct DAGUI_API PointerEvent
	{
        std::int32_t pos[2];
		ButtonMask buttons{ BUTTON_NONE };

        std::int32_t x() const
        {
            return pos[0];
        }

        std::int32_t y() const
        {
            return pos[1];
        }

		void configure(dagbase::ConfigurationElement& config);

		bool operator==(const PointerEvent& other) const;
	};

	//! A key press/release event
	struct DAGUI_API KeyEvent
	{
		std::uint32_t code{ 0 };

		bool operator==(const KeyEvent& other) const;
	};

	struct DAGUI_API WidgetEvent
	{
		Widget* widget{ nullptr };

		bool operator==(const WidgetEvent& other) const;
	};

	//! An occurrence that has already happened.
	//! Immutable once created.
	class DAGUI_API Event
	{
	public:
		using ContentType = std::variant<PointerEvent, KeyEvent, WidgetEvent>;
		enum Type : std::uint32_t
		{
			//! An unknown event
			TYPE_UNKNOWN,
			//! Generated when a pointing device moves
			TYPE_POINTER_MOVE,
			//! Generated when a pointing device stays 
			//! within a threshold distance of an initial position 
			//! over a Widget for a threshold duration
			TYPE_POINTER_HOVER,
			//! Generated when a button is pressed
			TYPE_BUTTON_PRESS,
			//! Generated when a button is released
			TYPE_BUTTON_RELEASE,
			//! Generated by a sequence of press then release 
			//! of the same button over the same Widget
			TYPE_BUTTON_CLICK,
            //! Generated by a sequence of two clicks
            TYPE_BUTTON_DOUBLE_CLICK,
			//! Generated by pressing a key
			TYPE_KEY_PRESS,
			//! Generated by releasing a key
			TYPE_KEY_RELEASE,
			//! Generated by a pointer entering the bounds of a Widget
			TYPE_ENTER_WIDGET,
			//! Generated by a pointer leaving the bounds of a Widget
			TYPE_LEAVE_WIDGET,
			//! Generated when a drag operation starts
			TYPE_DRAG_START,
			//! Generated while a drag operation is in progress
			TYPE_DRAGGING,
			//! Generated when a drag operation finishes
			TYPE_DRAG_STOP
		};
        enum TypeMask : std::uint32_t
        {
            EVENT_NONE,
            POINTER_MOVE_BIT = 1<<TYPE_POINTER_MOVE,
            POINTER_HOVER_BIT = 1<<TYPE_POINTER_HOVER,
            BUTTON_PRESS_BIT = 1<<TYPE_BUTTON_PRESS,
            BUTTON_RELEASE_BIT = 1<<TYPE_BUTTON_RELEASE,
            BUTTON_CLICK_BIT = 1<<TYPE_BUTTON_CLICK,
            BUTTON_DOUBLE_CLICK_BIT = 1<<TYPE_BUTTON_DOUBLE_CLICK,
            KEY_PRESS_BIT = 1<<TYPE_KEY_PRESS,
            KEY_RELEASE_BIT = 1<<TYPE_KEY_RELEASE,
            ENTER_WIDGET_BIT = 1<<TYPE_ENTER_WIDGET,
            LEAVE_WIDGET_BIT = 1<<TYPE_LEAVE_WIDGET,
            DRAG_START_BIT = 1<<TYPE_DRAG_START,
            DRAGGING_BIT = 1<<TYPE_DRAGGING,
            DRAG_STOP_BIT = 1<<TYPE_DRAG_STOP
        };
	public:
		Event() = default;

		Event(Type type, ContentType data);

		Type type() const
		{
			return _type;
		}

        void setTimestamp(double timestamp)
        {
            _timestamp = timestamp;
        }

        double timestamp() const
        {
            return _timestamp;
        }

		const ContentType& data() const
		{
			return _data;
		}

        ContentType & data()
        {
            return _data;
        }

        std::int32_t const * pos() const
        {
            if (_data.index() == 0)
            {
                return std::get<0>(_data).pos;
            }

            return ORIGIN;
        }

		bool operator==(const Event& other) const;

		void configure(dagbase::ConfigurationElement& config);

		static const char* typeToString(Type value);

		static Type parseType(const char* str);

        static std::string typeMaskToString(TypeMask value);

        static TypeMask parseTypeMask(const std::string& str);

        static constexpr std::int32_t ORIGIN[2]{};
	private:
		Type _type{ TYPE_UNKNOWN };
		double _timestamp{0.0};
		ContentType _data;
	};

    std::ostream DAGUI_API & operator<<(std::ostream& str, const Event& obj);
}
